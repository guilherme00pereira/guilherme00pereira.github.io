[{"categories":null,"contents":"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea\n","permalink":"https://guilherme00pereira.github.io/pt/contato/","tags":null,"title":"Entre em Contato"},{"categories":null,"contents":"Olá, sou analista e desenvolvedor de sistemas com mais de 8 anos de experiência, tendo já trabalhado em diferentes tipos de projetos, desde o desenvolvimento de sites e sistemas de e-commerce até em desenvolvimento de APIs e sistemas de back-end. Além disso, tenho diferentes níveis de conhecimento em várias linguagens de programação. Atualmente desenvolvendo soluções com Node.js, Vue.js, Nuxt.js e e-commerces com WordPress / WooCommerce.\n","permalink":"https://guilherme00pereira.github.io/pt/sobre-mim/","tags":null,"title":"Sobre Mim"},{"categories":["Wordpress"],"contents":" O WooCommerce tem uma REST API totalmente integrada à API do WordPress, que nos permite fazer solicitações no formato JSON para criar, ler, modificar e apagar dados de nossa loja. No entanto, às vezes, precisamos estender essa API, criando pontos de extremidade personalizados para retornar certos tipos de dados.\nNeste tutorial, mostrarei passo a passo como criar um endpoint personalizado simples e espero que isso seja útil como ponto de partida para que se possa desenvolver chamadas mais complexas.\nCriando o plugin Primeiramente, precisamos criar nosso plugin. A documentação do WordPress nos dá uma explicação completa sobre como criar um plugin próprio, mas basicamente o que temos que fazer é criar uma pasta dentro do diretório wp-content/plugins e dar um nome, como a seguir:\nmkdir woocommerce-custom-api-endpoint \u0026amp;\u0026amp; cd woocommerce-custom-api-endpoint Dentro desta pasta devemos criar um arquivo como o mesmo nome da pasta, o qual será nosso arquivo base do plugin:\ntouch woocommerce-custom-api-endpoint.php Definindo a Estrutura Básica Agora, no arquivo que criamos vamos escrever o seguinte código, com as seguintes partes (1, 2 e 3) que iremos explicar a seguir:\n\u0026lt;?php\r// (1)\rif ( ! defined( \u0026#39;ABSPATH\u0026#39; ) ) {\rexit;\r}\r// (2)\rfunction register_custom_routes() {\r}\r// (3)\radd_action(\u0026#39;rest_api_init\u0026#39;, \u0026#39;register_custom_routes\u0026#39;);\r?\u0026gt;  A primeira parte (1) do código evita o acesso direto ao arquivo. Em seguida (2), definimos uma função que irá fazer a chamada para o método da classe WC_Custom_Endpoints que iremos criar a seguir, onde estarão configuradas as rotas da nossa API. No passo (3) estaremos registrando nossos endpoints através do hook rest_api_init, passando como parâmetro a função criada. A Classe WC_Custom_Endpoints Agora vamos criar um novo arquivo que conterá nossa classe WC_Custom_Endpoints, onde estarão os métodos que tratarão as chamadas à nossa API. Para exemplarmos uma chamada à nossa API, criaremos um endpoint que retornará a listagem dos itens presentes nos pedidos com status \u0026ldquo;Processando\u0026rdquo;, ou seja, pedidos já pagos e pendentes de serem separados para envio, o que nos dará uma visão da quantidade de cada item a ser separado. Para isso definiremos a nossa classe com os seguintes métodos:\n\u0026lt;?php\rif ( ! defined( \u0026#39;ABSPATH\u0026#39; ) ) {\rexit;\r}\r// (1)\rclass WC_Custom_Endpoint extends WP_REST_Controller{\r// (2)\r private $local_wpdb;\r// (3)\r public function __construct() {\rglobal $wpdb;\r$this-\u0026gt;local_wpdb = $wpdb;\r}\r// (4)\r public function register_routes() {\r}\r// (5)\r public function processing_order_items() {\r}\r}\r?\u0026gt;  Criamos então a classe WC_Custom_Endpoints em um novo arquivo. Vamos criar um pasta chamada includes, e dentro dela criaremos o arquivo class-wc-custom-api-endpoints.php. Extenderemos a classe WP_REST_Controller (1) da qual iremos herdar o método \u0026ldquo;register_routes\u0026rdquo; (4), que irá registrar nossa rota de exemplo. Também declararemos uma propriedade privada $local_wpdb(2), que será instanciada em nosso método construtor da classe(3). A classe wpdb do WordPress contém funcionalidades para interagir com o banco de dados e iremos utilizá-la para executar uma query que retornará os dados que precisamos. Para isso criamos o método chamado processing_order_items (5).\nPara registrarmos nosso endpoint, vamos declarar uma variável que conterá nosso namespace e chamar a função register_rest_route passando como parâmetros o namespace, a definição da rota, e os argumentos no forma de um array. Este array conterá um outro array com as opções \u0026lsquo;methods\u0026rsquo; e o \u0026lsquo;callback\u0026rsquo;. Como faremos uma chamada GET, usaremos a constante READABLE, da classe WP_REST_Server. No callback passaremos nosso método que retornará os itens dos pedidos.\n\u0026lt;?php\rpublic function register_routes() {\r$namespace = \u0026#39;customapi/v1\u0026#39;;\rregister_rest_route($namespace, \u0026#39;/processing_order_items\u0026#39;, array(\rarray(\r\u0026#39;methods\u0026#39; =\u0026gt; WP_REST_Server::READABLE,\r\u0026#39;callback\u0026#39;\t=\u0026gt; array( $this, \u0026#39;processing_order_items\u0026#39; )\r)\r));\r}  Feito isso, agora faremos a query SQL dentro do método para acessar o banco de dados.\n\u0026lt;?php\rpublic function processing_order_items() {\r$sql = \u0026#34;SELECT woi.order_id, woi.order_item_name AS item_name, MAX(IF(wom.meta_key = \u0026#39;_qty\u0026#39;, wom.meta_value, NULL)) AS qty FROM wpsu_woocommerce_order_items woi\rINNER JOIN wpsu_woocommerce_order_itemmeta wom ON wom.order_item_id = woi.order_item_id\rWHERE woi.order_id IN (SELECT ID FROM wpsu_posts WHERE post_status = \u0026#39;wc-processing\u0026#39; AND post_type = \u0026#39;shop_order\u0026#39;)\rAND woi.order_item_type = \u0026#39;line_item\u0026#39;\rGROUP BY woi.order_item_name\u0026#34;;\r$result = $this-\u0026gt;local_wpdb-\u0026gt;get_results($sql);\rreturn $result;\r}  Pronto, nosso endpoint agora está quase pronto. Ficou faltando apenas voltarmos no arquivo base de nosso plugin, woocommerce-custom-api-endpoint.php, e adicionarmos o seguinte código dentro da função register_custom_routes, e incluir a classe WC_Custom_Endpoint, como a seguir:\n\u0026lt;?php\rif ( ! defined( \u0026#39;ABSPATH\u0026#39; ) ) {\rexit; // Exit if accessed directly.\r}\rif ( ! class_exists( \u0026#39;WC_Custom_Endpoint\u0026#39; ) ) {\rinclude_once dirname( __FILE__ ) . \u0026#39;/includes/class-wc-custom-api-endpoints.php\u0026#39;;\r}\rfunction register_custom_routes() {\r$controller = new WC_Custom_Endpoint(); $controller-\u0026gt;register_routes();\r}\radd_action(\u0026#39;rest_api_init\u0026#39;, \u0026#39;register_custom_routes\u0026#39;);  Agora sim poderemos realizar nossa chamada, como por exemplo:\ncurl \u0026#34;http://www.seusite.com/wp-json/customapi/v1/processing_order_items Este é um exemplo básico, poderíamos estender este artigo tratando de de outras questões, como autenticação para realizar a chamada, mas isto será assunto para um futuro post.\nAté mais!\n","permalink":"https://guilherme00pereira.github.io/pt/blog/creating-a-custom-endpoint-for-wordpress-woocommerce-rest-api/","tags":["wordpress","woocommerce","api"],"title":"Criando Endpoints Customizados para API do WordPress / WooCommerce"},{"categories":null,"contents":"","permalink":"https://guilherme00pereira.github.io/pt/blog/creating-a-theme-for-wordpress/","tags":null,"title":""}]