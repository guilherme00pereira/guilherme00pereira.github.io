[{"categories":null,"contents":"Hello, I am an analyst and systems developer with more than 10 years of experience, working on different types of projects, from the development of websites and e-commerce systems to APIs and back-end systems. Also, i have different levels of knowledge in various programming languages. Currently enrolled in a few courses at DataCamp, Alura and Udemy. Developing solutions with Node.js, Vue.js and e-commerces with WordPress / WooCommerce.\n","permalink":"https://guilherme00pereira.github.io/about/","tags":null,"title":"About Me"},{"categories":null,"contents":"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea\n","permalink":"https://guilherme00pereira.github.io/contact/","tags":null,"title":"Get In Touch"},{"categories":["Wordpress"],"contents":" WooCommerce has a REST API fully integrated with the WordPress API, which allows us to make requests in JSON format to create, read, modify and erase data from our store. However, sometimes we need to extend this API by creating custom endpoints to return certain types of data.\nIn this tutorial, I\u0026rsquo;ll show you step-by-step how to create a simple custom endpoint and hopefully this will be useful as a starting point for more complex calls.\nCreating the Plugin First of all, we will create our WordPress plugin. WordPress docs give us a full explanation about how to create your own plugin, but basically what we have to do is to create a folder inside wp-content/plugins directory, and give it a name:\nmkdir woocommerce-custom-api-endpoint \u0026amp;\u0026amp; cd woocommerce-custom-api-endpoint Inside that folder, we create a file with the same folder\u0026rsquo;s name, and it\u0026rsquo;ll contain our base code:\ntouch woocommerce-custom-api-endpoint.php The Basic Structure Now, in the file that we created we will write the following code, with the following parts (1, 2 and 3) that i will explain next:\n\u0026lt;?php\r// (1)\rif ( ! defined( \u0026#39;ABSPATH\u0026#39; ) ) {\rexit;\r}\r// (2)\rfunction register_custom_routes() {\r}\r// (3)\radd_action(\u0026#39;rest_api_init\u0026#39;, \u0026#39;register_custom_routes\u0026#39;);\r?\u0026gt;  The first part (1) of the code avoids direct access to the file. Then (2), we define a function that will make the call to the class method WC_Custom_Endpoints that we will create in the next step, where the routes of our API will be configured. In step (3) we will be registering our endpoints through the hook rest_api_init, passing as parameter the created function.\nWC_Custom_Endpoints Class Now let\u0026rsquo;s create a new file that will contain our WC_Custom_Endpoints class, which will be the methods that will handle calls to our API. To copy a call to our API, we will create an endpoint that will return the list of the items present in the orders with status \u0026ldquo;Processing\u0026rdquo;, i.e., orders already paid and pending to be separated for sending, which will give us an overview of the quantity of each item to be separated. For this we will define our class with the following methods:\n\u0026lt;?php\rif ( ! defined( \u0026#39;ABSPATH\u0026#39; ) ) {\rexit;\r}\r// (1)\rclass WC_Custom_Endpoint extends WP_REST_Controller{\r// (2)\r private $local_wpdb;\r// (3)\r public function __construct() {\rglobal $wpdb;\r$this-\u0026gt;local_wpdb = $wpdb;\r}\r// (4)\r public function register_routes() {\r}\r// (5)\r public function processing_order_items() {\r}\r}\r?\u0026gt;  We then create the WC_Custom_Endpoints class in a new file. Let\u0026rsquo;s create a folder called includes, and within it we will create the file class-wc-custom-api-endpoints.php. We will extend the WP_REST_Controller (1) class, from which we will inherit the \u0026ldquo;register_routes\u0026rdquo; method (4), which will register our example route. We will also declare a private property $local_wpdb(2), which will be instantiated in our class constructor (3) method. The wpdb class of WordPress contains features to interact with the database and we will use it to execute a query that will return the data we need. For this we create the method called processing_order_items (5).\nTo register our endpoint, we will declare a variable that will contain our namespace and call the register_rest_route function, passing the namespace, route definition, and arguments as an array with parameters. This array will contain another array with options \u0026lsquo;methods\u0026rsquo; and \u0026lsquo;callback\u0026rsquo;. Since we will make a GET call, we will use the READABLE constant of the WP_REST_Server class. In the callback we will pass our method that will return the items of the orders.\n\u0026lt;?php\rpublic function register_routes() {\r$namespace = \u0026#39;customapi/v1\u0026#39;;\rregister_rest_route($namespace, \u0026#39;/processing_order_items\u0026#39;, array(\rarray(\r\u0026#39;methods\u0026#39; =\u0026gt; WP_REST_Server::READABLE,\r\u0026#39;callback\u0026#39;\t=\u0026gt; array( $this, \u0026#39;processing_order_items\u0026#39; )\r)\r));\r}  That done, we will now do the SQL query within the method to access the database.\n\u0026lt;?php\rpublic function processing_order_items() {\r$sql = \u0026#34;SELECT woi.order_id, woi.order_item_name AS item_name, MAX(IF(wom.meta_key = \u0026#39;_qty\u0026#39;, wom.meta_value, NULL)) AS qty FROM wpsu_woocommerce_order_items woi\rINNER JOIN wpsu_woocommerce_order_itemmeta wom ON wom.order_item_id = woi.order_item_id\rWHERE woi.order_id IN (SELECT ID FROM wpsu_posts WHERE post_status = \u0026#39;wc-processing\u0026#39; AND post_type = \u0026#39;shop_order\u0026#39;)\rAND woi.order_item_type = \u0026#39;line_item\u0026#39;\rGROUP BY woi.order_item_name\u0026#34;;\r$result = $this-\u0026gt;local_wpdb-\u0026gt;get_results($sql);\rreturn $result;\r}  Okay, our endpoint is now almost done. We just needed to go back to the base file of our plugin, woocommerce-custom-api-endpoint.php, and add the following code inside the register_custom_routes function, and include the WC_Custom_Endpoint class, as follows:\n\u0026lt;?php\rif ( ! defined( \u0026#39;ABSPATH\u0026#39; ) ) {\rexit; // Exit if accessed directly.\r}\rif ( ! class_exists( \u0026#39;WC_Custom_Endpoint\u0026#39; ) ) {\rinclude_once dirname( __FILE__ ) . \u0026#39;/includes/class-wc-custom-api-endpoints.php\u0026#39;;\r}\rfunction register_custom_routes() {\r$controller = new WC_Custom_Endpoint(); $controller-\u0026gt;register_routes();\r}\radd_action(\u0026#39;rest_api_init\u0026#39;, \u0026#39;register_custom_routes\u0026#39;);  Now we call our endpoint:\ncurl \u0026#34;http://www.seusite.com/wp-json/customapi/v1/processing_order_items This is a basic example, we could extend this article by addressing other issues, such as authentication to hold the call, but this will be subject to a future post.\nSee ya!\n","permalink":"https://guilherme00pereira.github.io/blog/creating-a-custom-endpoint-for-wordpress-woocommerce-rest-api/","tags":["wordpress","woocommerce","api"],"title":"Creating a Custom Endpoint for WordPress / WooCommerce REST API"}]